# 테마 7. 부동소수점 방식
 - 무한소수, 허수... 등은 메모리 문제로 완전히 묘사 불가
 - n bit 표현 : 고정 vs 부동
  - 개수는 2^n으로 동일, 부동소수점의 *표현 범위*가 더 넓다

 ### 1. 부동소수점 특징
 부호부 + 지수부(소수점 위치) + 가수부(유효숫자)

 - 최상위 비트 : 양수(0), 음수(1)
 - 지수부 부호 표현 X → bias 더하여 사용
   - 단일 정밀도(32bit) : 127
   - 이중정밀도(64bit) : 1023

 - 숫자 0 : 특수한 값으로 인식 → 모든 bit 0 표현

 ### 2. IEEE 754 표준 부동소수점 정규화 과정
  1. 2진수로 변환
  2. 정규화
  3. 32bit 단일 정밀도 표준
  4. (+α) 16진수 변환

 - 예제 : 13.625(10)   
  > 2진수로 변환 : -1101.101(2)    
  > 정규화 : -1.101101 * 2^3    (1.은 hidden bit로 저장X)
  > 표준 : 1 10000010 10110100... 부호+지수(+bias(127))+가수   

 - 만일 지수가 다르다면 큰 쪽을 기준으로 

 ### 3. 부동소수점 덧셈(뺄셈) 연산 순서
  - 연산 : 부호 판단 → 지수 맞추기 → 가수 조정 → 연산결과 정규화

  - 예제 -2.75 표준에 따라 2진수 표기
  > -10.11(2)
  > -1.011 * 2
  > 1'100 0000 0'011' 0000 0000 0000 0000 0000



# 테마 8. 연산자 우선순위
 ### 1. 연산자 우선 순위 
  1. 괄호 () 
  2. 산술 +, -, *, /, % (산술연산)
  3. 이동(시프트) '>>n'(오른쪽으로), '<<n' (산술연산)
  4. 관계(비교) >, >=, <, <=, ==, !=
  5. 비트 논리 &(AND), |(OR), ^(XOR), ~(!)(1의 보수) (논리연산)
  6. 논리 NOT AND OR NAND NOR XOR XNOR (논리연산) 
  7. 대입, 축약 =, +=
   - 공간, 위치 = (r-value)
  
  - 조건 연산자(삼항 연산자)  조건 ? T : F
  
 ### 2. 비트단위 논리연산
  - &, and : 2진수 특정 비트 선택적 0 (clear)
  - |, or : 2진수 특정 비트 선택적 1 (selective-set) 
  - ^, xor : 2진수 특정 비트 1의 보수로 변경 (selective-complement)
   - 1100 0100 XOR 1111 0000 = 0011 0100
  - 논리적 shift : 정해진 방향으로 비트가 이동 빈자리에는 0 삽입
  - 논리적 rotate : 비트 이동, 빈자리는 이동한 비트가 삽입


 ... 별로 중요하진 않다.
 ### 3. 산술적 이동 (shift)    
  1. 이동 과정에서 부호 비트는 유지
  2. 이동 비트 수 n개 : 왼쪽 이동 = *2^n, 오른쪽 = /2^n
  -             부호와 절대치   1의 보수     2의 보수
  - Left Shift  :   0           Sign        0
  - Right Shift :   0           Sign        Sign

  - 왼쪽 시프트 : * 2
  - 오른쪽 시프트 : / 2 

  - -15 (1111) >> 1 = -7.5(111) = -7 


