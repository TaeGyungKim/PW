# THEMA 6. 고정소수점 표현방식
 - ex) 정수
 
 1. 언팩 표현 (unpack)
  - 8bit로 숫자 1자리 표현
  - 숫자 zone (4bit) + 자리값 digit (4bit)
  - 각 zone : F(1111) 표시
  - 부호 : 가장 오른쪽 마지막 zone에 부호 표시 
      - 양수(+) : C (1100)
      - 음수(-) : D (1101)
  - I/O 표현용, 연산X

 2. 팩 표현 (pack)
  - 4bit로 숫자 1자리 표현
  - 부호 : 가장 오른쪽 4비트에 표시
      - 양수(+) : C(1100)
      - 음수(-) : D(1101)
  - 연산용, I/O X

 ### 1. 고정 소수점(Fixed Point) 표현 
  - 2진수 정수 표현시 사용
  - 정수 표현 방식 : 단정도 방식(16bit) + 배정도 방식(32bit)

  - 양수일 경우 부호 부 : 0, 정수부에 수치의 절댓값 표시 
  - 음수일 경우 부호 부(첫 비트): 1 표시 
     - 정수부 표시 -> 감산을 가산으로 해결



 ### 2. 표현 방식에 따른 범위
  1. 부호와 절대치
    - +0과 -0이 존재
    - 큰값과 작은값 표현에 또 다른 로직 필요

  2. 부호와 1의 보수
    -  001 보수→ 110
    - -0(111)은 여전히 존재

  3. 부호와 2의 보수
    - 1의보수 +1
    - -0 존재X
    - 음수의 범위가 1만큼 증가

  - ex) 4bit로 정수 표현시 (1011)
    > 1. 부호 사용 X(unsigned) : 11   
    >    범위   : 0 ~ 15

    > 2. 절대치 : -3     
    >    범위   : -7 ~ +7
    
    > 3. 1의 보수 : -4
    >    범위   : -7 ~ +7
    
    > 4. 2의 보수 : -5
    >   범위    : -8 ~ +7

 ### 3. 2진수 연산 (덧셈)
  #### (1) overflow 발생X 덧셈 연산
   - 양수 + 음수 : 오버플로우 발생 X
   - 양수 + 양수나 음수+음수: 오버플로우 발생할 수 있음

   > 1101 + 0101 = 1 0010  
   > : overflow 발생 X

  #### (2) overflow 발생 덧셈 연산
     - overflow 판단하기 위해서는 XOR 필요
     - carry XOR 최상위 비트 = 1 이면 overflow 
   1. 양수 + 양수
    > 0101 + 0100 = 1001 
    > : overflow
   2. 음수 + 음수
    > 1001 + 1010 = 1 0011
    > : overflow 
    > : 부호변경, XOR값 불일치 



   



